{
    "collab_server" : "",
    "contents" : "biglm::biglm\n#'@import biglm\n#'\nbackground.resp <-\n    function(data, DO.var.name, time.var.name = \"std.time\",\n             start.time, end.time, ...){\n        \n        orig = \"1970-01-01 00:00:00 UTC\"\n        data$y <- eval(parse(text = paste(\"data$\", DO.var.name, sep = \"\")))\n        data$x <- eval(parse(text = paste(\"data$\", time.var.name, sep = \"\")))\n        if(class(start.time) != class(end.time)) {\n            stop (\"start time and end time must be of same atomic class\")\n        }\n        if(is.character(start.time)==T){\n            data <- data[data$x >= as.POSIXct(start.time,\n                                              origin = orig) &\n                             data$x<= as.POSIXct(end.time,\n                                                 origin = orig),]  \n        }else if (class(start.time)[1]==(\"POSIXct\") &\n                      class(start.time)[2]==(\"POSIXt\")){\n            data <- data[data$x >= start.time &\n                             data$x <= end.time] \n        }\n        \n        \n        m1 <- biglm(y ~ x, data)\n        \n        MR1 <- coef(m1)[2]\n        if (MR1>=0){warning(\"slope control 1 negative\")}\n        plot(y ~ x, data,...)\n        abline(coefficients(m1), col=\"red\", lwd=2.5)\n        return(summary(m1))\n    }\n\n#'@export\nbiglm::biglm\n\n\nBarom.Press <-\n    function(elevation.m, units = \"atm\"){\n        if(units == \"atm\") {fact <-1}\n        else if(units == \"kpa\") {\n            fact <- 101.325\n        }else if(units == \"mmHg\") {\n            fact <- 760\n        }else{\n            stop(\"invalid pressure units, must be\n             'atm', 'kpa', or 'mmHg'\")\n        }\n        P<-exp(-9.80665 * 0.0289644 * elevation.m / \n                   (8.31447 * 288.15))*fact\n        return(P)\n    }\n\n#'@export\n#'@import biglm\n#'\nDO.saturation <-\n    function(DO.mgl, temp.C, elevation.m = NULL,\n             bar.press = NULL, bar.units = \"atm\"){\n        DO.sat<- DO.mgl / Eq.Ox.conc(temp.C, elevation.m,\n                                     bar.press, bar.units)\n        return(DO.sat)\n    }\n#'@export\n#'@import biglm \n#'\n\n\nDO.unit.convert <-\n    function(x, DO.units.in, DO.units.out, \n             bar.units.in, bar.press, temp.C,\n             bar.units.out){\n        if(bar.units.in == bar.units.out){\n            bar.press <- bar.press\n        }else if(bar.units.in == \"atm\"){\n            if(bar.units.out == \"mmHg\"){\n                bar.press <- bar.press * 760\n            }else if(bar.units.out == \"kpa\"){\n                bar.press <- bar.press * 101.32501\n            }else{\n                stop(\"invalid 'bar.units.out' -- must be 'atm', 'mmHg', 'kpa'\")\n            }\n        }else if(bar.units.in == \"mmHg\"){\n            if(bar.units.out == \"atm\"){\n                bar.press <- bar.press / 760\n            }else if(bar.units.out == \"kpa\"){\n                bar.press <- bar.press * 101.32501 / 760\n            }else{\n                stop(\"invalid 'bar.units.out' -- must be 'atm', 'mmHg', 'kpa'\")\n            }\n        }else if(bar.units.in == \"kpa\"){\n            if(bar.units.out == \"atm\"){\n                bar.press <- bar.press / 101.32501\n            }\n            if(bar.units.out == \"mmHg\"){\n                bar.press <- bar.press * 760 / 101.32501\n            }\n        }\n        \n        \n        if (DO.units.in == \"pct\"){\n            DO.pct <- x / 100\n        }else{\n            eq.o2.in <- Eq.Ox.conc(temp.C, bar.units = bar.units.out, \n                                   bar.press =bar.press,\n                                   out.DO.meas = DO.units.in)\n            DO.pct <- x / eq.o2.in\n        }\n        \n        if (DO.units.out == \"pct\"){\n            DO.conc <- DO.pct * 100\n        }else{\n            eq.o2.out <- Eq.Ox.conc(temp.C, bar.units = bar.units.out,\n                                    bar.press = bar.press,\n                                    out.DO.meas = DO.units.out)\n            DO.conc <- DO.pct * eq.o2.out\n        }\n        \n        return(DO.conc)\n    }\n#'@export\n#'@import biglm\n#'\nEq.Ox.conc <-\n    function(temp.C, elevation.m = NULL,\n             bar.press = NULL, bar.units = \"atm\",\n             out.DO.meas = \"mg/L\"){\n        \n        if( out.DO.meas == \"PP\"){\n            \n            if(is.null(bar.press) == FALSE && is.null(elevation.m) == TRUE){\n                bar.press <- bar.press\n            } else if(is.null(bar.press) == TRUE &&\n                          is.null(elevation.m) == FALSE){\n                bar.press <- Barom.Press (elevation.m, units = bar.units)\n            }else{\n                stop(\"EITHER 'elevation.m' or 'barom.press' must be assigned\n                     a value. The other argument must be NULL.\")\n            }\n            \n            Cp <-bar.press*0.20946 \n            \n            }else if (out.DO.meas == \"mg/L\"){\n                std.Eq.Ox.conc <- exp(7.7117 - 1.31403*(log(temp.C + 45.93)))\n                if(is.null(bar.press) == FALSE && is.null(elevation.m) == TRUE){\n                    if(bar.units == \"atm\"){\n                        bar.press <- bar.press\n                    }else if(bar.units == \"kpa\"){\n                        bar.press <- bar.press / 101.325\n                    }else if(bar.units == \"mmHg\"){\n                        bar.press <- bar.press / 760\n                    }else{\n                        stop(\"invalid pressure units, must be\n                         'atm', 'kpa', or 'mmHg'\")\n                    }\n                } else if(is.null(bar.press) == TRUE &&\n                              is.null(elevation.m) == FALSE){\n                    bar.press <- Barom.Press (elevation.m, units = bar.units)\n                }else{\n                    stop(\"EITHER 'elevation.m' or 'barom.press' must be assigned\n                         a value. The other argument must be NULL.\")\n                }\n                \n                temp.K <- 273.15 + temp.C\n                P.H2Ovap <- exp(11.8571 - (3840.7 / temp.K) - (216961/(temp.K^2)))\n                theta <- 0.000975 - (1.426e-5 * temp.C) +(6.436e-8 * temp.C^2) \n                \n                Cp <- std.Eq.Ox.conc*bar.press * \n                    ((1-(P.H2Ovap/bar.press))*1-(theta*bar.press))/\n                    ((1-P.H2Ovap)*(1-theta))\n            }else{\n                stop(\"must specify 'out.DO.meas' as 'mg/L' or 'PP'\")\n            }\n        \n        return(Cp)\n    }\n\n#'@export\n#'@import biglm\n#'\n\nget.pcrit <-\n    function(data, DO = NULL, MR = NULL, Pcrit.below,\n             idx.interval = NULL, index.var = \"std.time\",\n             start.idx = NULL, stop.idx = NULL, ...){\n        \n        data$DO <- eval(parse(text = paste(\"data$\", DO, sep = \"\")))\n        \n        if(any(is.na(data$DO)==T)){\n            warning(\"DO variable contains missing values\")\n        } \n        \n        if(is.null(MR) == TRUE){\n            \n            if(is.null(idx.interval)){\n                stop(\"if 'MR' = NULL, 'interval' must be specified\")\n            }\n            \n            \n            data$idx <- eval(parse(text =\n                                       paste(\"data$\", index.var, sep = \"\")))\n            \n            \n            data <- data[data$idx >= start.idx\n                         & data$idx <= stop.idx,]\n            \n            \n            data$idx <- as.numeric(data$idx) - min(as.numeric(data$idx))\n            \n            calc.MRs <- data.frame()\n            \n            i<-0\n            \n            while(i + idx.interval < length(data$idx)){\n                the.interval <- data[data$idx >= i &\n                                         data$idx < i + idx.interval,]\n                m <- lm(DO ~ idx, data = the.interval)\n                MR <- m$coefficients[2]*(-1)\n                DO <- mean(the.interval$DO, na.rm = TRUE)\n                time <- round(the.interval$idx[1])\n                df.row <- t(c(DO, MR))\n                calc.MRs <- rbind(calc.MRs, df.row)\n                i <- i + idx.interval\n                \n            }\n            \n            \n            data <- calc.MRs\n            names(data) <- c(\"DO\", \"MR\")\n            \n        }else if(is.null(MR) == FALSE){\n            data$MR <- eval(parse(text = paste(\"data$\", \"MR\", sep = \"\")))\n        }\n        \n        \n        \n        \n        minimum.DO <- \n            as.numeric(min(data[data$DO <= Pcrit.below, 1], na.rm=TRUE))\n        \n        zone.of.interest <- data[data$DO <= Pcrit.below,]\n        zone.of.interest <- zone.of.interest[order(zone.of.interest$DO, \n                                                   decreasing=TRUE),]\n        \n        RSS.table<-data.frame()\n        for(w in 2:length(zone.of.interest[,1])-1){\n            if(zone.of.interest$DO[w] != minimum.DO){\n                break.point <- zone.of.interest$DO[w]\n                RSS <- tot.rss(data = data,\n                               break.pt = break.point,\n                               xvar = \"DO\", yvar = \"MR\")\n                RSS.row <- cbind(RSS, zone.of.interest$DO[w])\n                RSS.table <- rbind(RSS.table,RSS.row)    \n            }\n        }\n        \n        DO.idx <- RSS.table[RSS.table$RSS == min(RSS.table$RSS), 2]\n        \n        \n        \n        ##creating linear models##\n        dat1 <- data[data$DO > DO.idx,]\n        mod.1 <- lm(dat1$MR~dat1$DO)\n        \n        dat2 <- data[data$DO <= DO.idx,]\n        mod.2 <- lm(dat2$MR ~ dat2$DO)\n        \n        sm1 <- summary(mod.1)\n        sm2 <- summary(mod.2)\n        \n        adjr2.pre <- sm1$adj.r.squared\n        adjr2.post <- sm2$adj.r.squared\n        \n        ## Plot ##\n        \n        plot(MR~DO, data, type= \"n\", ...)\n        points(x = c(dat1$DO, dat2$DO), y = c(dat1$MR, dat2$MR), \n               cex = .7, ...)\n        intersect<-(mod.2$coefficients[1] - mod.1$coefficients[1]) /\n            (mod.1$coefficients[2] - mod.2$coefficients[2])\n        names(intersect)<-NULL\n        if(is.na(mod.2$coefficients[2])==T){\n            abline(mod.1$coefficients[1], 0)\n        }else{abline(coef = mod.1$coefficients, col=\"red\", lwd = 1.5, ...)}\n        abline(coef = mod.2$coefficients, col = \"red\", lwd = 1.5, ...)\n        points(x = intersect, y = mod.1$coefficients[1] +\n                   mod.1$coefficients[2]*intersect, pch=21,\n               col = \"blue\", cex=1.5)\n        dat.pre<-data[data$DO>=(2*intersect),]\n        \n        P.crit<-as.data.frame(cbind(intersect, adjr2.pre, adjr2.post))\n        names(P.crit)<-c(\"Pcrit\", \"Adj.r2.above\", \"Adj.r2.below\")\n        above.Pc <- mod.1\n        names(above.Pc) <- paste(\"above\",names(above.Pc),\n                                 sep=\".\")\n        below.Pc <- mod.2\n        names(below.Pc) <- paste(\"below\",names(below.Pc),\n                                 sep=\".\")\n        Pc<-as.list(c(P.crit, above.Pc,below.Pc))\n        return(Pc)\n        names(Pc)\n    }\n#'@export\n#'@import biglm\n#'\n#'\nget.witrox.data <-\n    function(data.name, lines.skip, delimit=\"tab\", choose.names = F,\n             chosen.names = NULL,\n             format){\n        if(delimit == \"tab\"){\n            separate = \"\\t\"\n        }else if(delimit == \"space\"){\n            separate = \"\"\n        }else if(delimit == \"comma\"){\n            separate = \",\"\n        }\n        \n        if(choose.names==F){\n            d<-read.table(file.choose(), sep=separate, skip=lines.skip,\n                          header =T,check.names=F)\n            invalid.names<-colnames(d)\n            valid.names<-make.names(colnames(d))\n            var.names<-NULL\n            for(i in 1:length(invalid.names)){\n                if(invalid.names[i] == valid.names[i]){\n                    var.names[i] <- valid.names[i]\n                }else{\n                    split.name.period <- as.vector(\n                        strsplit(valid.names[i], fixed = T,\n                                 split = \".\")[[1]])\n                    split.name.period <- paste(split.name.period, sep=\"\",\n                                               collapse=\"\")\n                    split.name <- as.vector(\n                        strsplit(split.name.period, fixed = F,\n                                 split = c(\"Â\"))[[1]])\n                    split.name <- paste(split.name, sep=\".\", collapse=\".\")\n                    var.names[i] <-  as.vector(\n                        strsplit(split.name, fixed = F,\n                                 split = c(\"â\"))[[1]])\n                }\n            }\n        }else if(choose.names==T){\n            d<-read.table(data.name, sep = separate, skip = lines.skip,\n                          header = F)\n            var.names<-chosen.names\n        }\n        \n        colnames(d) <- var.names\n        d[,1]<-as.character(d[,1]) \n        d$std.time <- as.POSIXct(strptime(d[,1], format = format),\n                                 origin = \"1970-01-01 00:00:00 UTC\")\n        return(d)\n        \n    }\n#'@export\n#'@import biglm\n\nMR.loops <-\n    function(data, DO.var.name, time.var.name = \"std.time\",\n             in.DO.meas = \"mg/L\", out.DO.meas = \"mg/L\",\n             start.idx, stop.idx, system.vol = 1,\n             background.consumption = NULL,\n             background.start = NULL, background.end = NULL,\n             temp.C, elevation.m = NULL,\n             bar.press = NULL, bar.units = \"atm\", ...){\n        ## format the time vectors into POSIX ##\n        orig = \"1970-01-01 00:00:00 UTC\"\n        start.idx <- as.POSIXct((start.idx), origin = orig)\n        stop.idx <- as.POSIXct((stop.idx), origin = orig)\n        \n        if (length(start.idx) != length(stop.idx)){\n            stop (\"number of start times not equal\n                  to number of stop times\")\n        }\n        \n        ## set response variable ##\n        data$y <- eval(parse(text = paste(\"data$\", DO.var.name, sep = \"\")))\n        ## set time variable ##\n        data$x <- eval(parse(text = paste(\"data$\", time.var.name, sep = \"\")))\n        \n        ## set background DO consumption rate ##\n        if(is.null(background.consumption) == TRUE){\n            bgd.info <- background.resp(DO.var.name = \"y\", data, \n                                        time.var.name = \"x\",\n                                        background.start, background.end)\n            bgd.slope <- bgd.info$mat[2,1]\n        }else if(is.null(background.consumption) == FALSE) {\n            bgd.slope = background.consumption\n        }\n        \n        if(is.null(bar.press) == FALSE && is.null(elevation.m) == FALSE){\n            stop(\"Either 'bar.press' or 'elevation.m' should be NULL\")\n        }\n        \n        ## barometric pressure ##\n        if(is.null(bar.press) == FALSE){\n            if(is.character(bar.press) == TRUE){\n                bar.press <- eval(parse(\n                    text = paste(\"data$\",\n                           bar.press, sep = \"\")))\n            }else if(is.numeric(bar.press) == TRUE){\n                bar.press <- bar.press\n            }else{\n               stop(\"'bar.press' must be 'NULL', numeric, or\n                      the col.name for barometric pressure\")\n            }\n            }\n        \n        \n        \n        ## Temperature ##\n        if (is.character(temp.C) == TRUE){\n            temp.C <- eval(parse(\n                text = paste(\"data$\", temp.C, sep = \"\")))\n        }else if(is.numeric(temp.C) == TRUE){\n            temp.C <- temp.C\n        }else{\n            stop(\"invalid temp.C argument\")\n        }\n        \n        # DO sat conversions #\n        if (in.DO.meas == \"pct\"){\n            data$y <- (data$y /100) * \n                Eq.Ox.conc(temp.C, elevation.m,\n                           bar.press, bar.units,\n                           out.DO.meas)\n        }else if (in.DO.meas == \"PP\"){\n            fraction <- data$y / \n                Eq.Ox.conc(temp.C, elevation.m,\n                           bar.press, bar.units,\n                           out.DO.meas = \"PP\")\n            data$y <- fraction *\n                Eq.Ox.conc(temp.C, elevation.m,\n                           bar.press, bar.units,\n                           out.DO.meas)\n        }else if(in.DO.meas == \"mg/L\"){\n            data$y <- data$y\n        }else{\n            stop(\"invalid 'in.DO.meas' argument:\n                 must be 'pct', 'PP', or 'mg/L' \")\n        }\n        \n        data$y <- system.vol * data$y\n        # Now data$y in units of mg #\n        \n        data$adj.y <- data$y - (as.numeric(data$x) -\n                      as.numeric(start.idx[1]))*bgd.slope\n        \n        plot(adj.y ~ x,\n             data = data[(data$x >= start.idx[1] - 600) &\n                    data$x <= (tail(stop.idx,1) + 600),],\n                    type=\"n\",...)\n        \n        name.num<-as.character(c(1:length(start.idx)))\n        ms<-list()\n        MR.summary<-data.frame()\n        for(i in 1:length(start.idx)){\n            dat <- data[data$x >= start.idx[i]\n                        & data$x <= stop.idx[i],]\n            \n            dat$y <- dat$y - (as.numeric(dat$x-\n                                             as.numeric(start.idx[i]))*bgd.slope )\n            \n            mk <- biglm(y ~ x, dat)\n            ms[[i]] <- mk\n            \n            points(dat$x, dat$y)\n            names(ms[[i]])<-paste(names(ms[[i]]), name.num[i], sep=\".\")\n            abline(coef(ms[[i]]),\n                   col=\"red\",  lwd = 2)\n            \n            MR <- coef(mk)[2]*-1\n            sds <- summary(mk)$mat[2,4]*sqrt(length(dat[,1]))\n            rsquare <- summary(mk)$rsq\n            mrrow <- t(c(MR, sds, rsquare))\n            MR.summary <- rbind(MR.summary,mrrow)\n        }\n        names(MR.summary) <- c(\"MR\", \"sd.slope\", \"r.square\")\n        ofthejedi <- list(MR.summary, ms)\n        names(ofthejedi) <- c(\"MR.summary\", \"lm.details\")\n        return(ofthejedi)\n        }\n\n#'@export\n#'@import biglm\n\nplot.raw <-\n    function(data, DO.var.name, time.var.name = \"std.time\",\n             start.time = data$x[1],\n             end.time = data$x[length(data$x)], ...){\n        orig = \"1970-01-01 00:00:00 UTC\"\n        \n        data$x <- eval(parse(text = paste(\"data$\", time.var.name, sep = \"\")))\n        data <- data[data$x >= start.time & data$x <= end.time,]\n        data$y <- eval(parse(text = paste(\"data$\", DO.var.name, sep = \"\")))\n        \n        plot(y~std.time, data, ...)\n    }\n\n#'@export\n#'@import biglm\n\nsumsq <-\n    function(x){\n        mx<-mean(x)\n        sq.dev<-((x-mx)^2)\n        sumsquares<-sum(sq.dev)\n        return(sumsquares)\n    }\n#'@export\n#'@import biglm\n#'\n\ntot.rss <-\n    function(data, break.pt, xvar, yvar){\n        data$x <- eval(parse(text = paste(\"data$\", xvar, sep=\"\")))\n        data$y <- eval(parse(text = paste(\"data$\", yvar, sep=\"\")))\n        d1 <- data[data$x >= break.pt,]\n        m1 <- lm(d1$y~d1$x)\n        \n        d2 <- data[data$x < break.pt,]\n        m2 <- lm(d2$y~d2$x)\n        \n        trss <- (sumsq(m1$residuals)+sumsq(m2$residuals))\n        return(trss)\n    }\n#'@export\n#'@import biglm\n#'\n\n",
    "created" : 1474921179251.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2885384101",
    "id" : "A2BEA202",
    "lastKnownWriteTime" : 1474405262,
    "last_content_update" : 1474405262,
    "path" : "~/rMR/R/rMR.R",
    "project_path" : "R/rMR.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}