data$MR <- data$MR * t.denom
}else if(is.null(MR) == FALSE){
data$MR <- eval(parse(text = paste("data$", MR, sep = "")))
}
minimum.DO <-
as.numeric(min(data[data$DO <= Pcrit.below, 1], na.rm=TRUE))
zone.of.interest <- data[data$DO <= Pcrit.below,]
zone.of.interest <- zone.of.interest[order(zone.of.interest$DO,
decreasing=TRUE),]
RSS.table<-data.frame()
for(w in 2:length(zone.of.interest[,1])-1){
if(zone.of.interest$DO[w] != minimum.DO){
break.point <- zone.of.interest$DO[w]
RSS <- tot.rss(data = data,
break.pt = break.point,
xvar = "DO", yvar = "MR")
RSS.row <- cbind(RSS, zone.of.interest$DO[w])
RSS.table <- rbind(RSS.table,RSS.row)
}
}
DO.idx <- RSS.table[RSS.table$RSS == min(RSS.table$RSS), 2]
idx.rname <- row.names(RSS.table[RSS.table[,2] == DO.idx,])
DO.idx.low <- RSS.table[row.names(RSS.table) ==
(as.numeric(idx.rname)-1), 2]
midpoint.approx <- mean(c(DO.idx, DO.idx.low))
##creating linear models##
dat1 <- data[data$DO > DO.idx,]
mod.1 <- lm(dat1$MR~dat1$DO)
dat2 <- data[data$DO <= DO.idx,]
mod.2 <- lm(dat2$MR ~ dat2$DO)
sm1 <- summary(mod.1)
sm2 <- summary(mod.2)
adjr2.pre <- sm1$adj.r.squared
adjr2.post <- sm2$adj.r.squared
## Plot: line intersect##
plot(MR~DO, data, type= "n", ...)
points(x = c(dat1$DO, dat2$DO), y = c(dat1$MR, dat2$MR),
cex = .7, ...)
intersect<-(mod.2$coefficients[1] - mod.1$coefficients[1]) /
(mod.1$coefficients[2] - mod.2$coefficients[2])
names(intersect)<-NULL
if(is.na(mod.2$coefficients[2])==T){
abline(mod.1$coefficients[1], 0)
}else{abline(coef = mod.1$coefficients, col="red", lwd = 1.5, ...)}
abline(coef = mod.2$coefficients, col = "red", lwd = 1.5, ...)
points(x = intersect, y = mod.1$coefficients[1] +
mod.1$coefficients[2]*intersect, pch=21,
col = "blue", cex=1.5)
if (Pcrit.type == "lm" | Pcrit.type == "both"){
abline(v = intersect, col = "blue", lwd = 1.5,...)
}
if (Pcrit.type == "midpoint" | Pcrit.type == "both"){
abline(v = midpoint.approx, col = "lightblue", lwd = 1.5,...)
}
dat.pre<-data[data$DO>=(2*intersect),]
P.crit<-as.data.frame(cbind(intersect, midpoint.approx,
adjr2.pre, adjr2.post))
names(P.crit)<-c("Pcrit.lm", "Pcrit.midpoint",
"Adj.r2.above", "Adj.r2.below")
above.Pc <- list(mod.1)
names(above.Pc) <- paste("above",names(above.Pc),
sep=".")
below.Pc <- list(mod.2)
names(below.Pc) <- paste("below",names(below.Pc),
sep=".")
Pc<-c(P.crit, above.Pc, below.Pc)
return(Pc)
}
Pcrit2 <-get.pcrit(data = fishMR, DO = "DO.mgL",
Pcrit.below = 2,
idx.interval = 60,
start.idx = "2015-07-03 06:15:00",
stop.idx = "2015-07-03 08:05:00",
time.units = "min")
get.pcrit <-
function(data, DO = NULL, MR = NULL, Pcrit.below,
idx.interval = NULL, index.var = "std.time",
start.idx = NULL, stop.idx = NULL,
time.units = "sec", Pcrit.type = "both",...){
data$DO <- eval(parse(text = paste("data$", DO, sep = "")))
## set time denominator based on specified time.units ##
if(time.units == "sec"){
t.denom <- 1
}else if(time.units == "min"){
t.denom <- 60
}else if(time.units == "hr"){
t.denom <- 3600
}
if(any(is.na(data$DO)==T)){
warning("DO variable contains missing values")
}
if(is.null(MR) == TRUE){
if(is.null(idx.interval)){
stop("if 'MR' = NULL, 'interval' must be specified")
}
data$idx <- eval(parse(text =
paste("data$", index.var, sep = "")))
data <- data[data$idx >= start.idx
& data$idx <= stop.idx,]
data$idx <- as.numeric(data$idx) - min(as.numeric(data$idx))
calc.MRs <- data.frame()
i<-0
while(i + idx.interval < length(data$idx)){
the.interval <- data[data$idx >= i &
data$idx < i + idx.interval,]
m <- lm(DO ~ idx, data = the.interval)
MR <- m$coefficients[2]*(-1)
DO <- mean(the.interval$DO, na.rm = TRUE)
time <- round(the.interval$idx[1])
df.row <- t(c(DO, MR))
calc.MRs <- rbind(calc.MRs, df.row)
i <- i + idx.interval
}
data <- calc.MRs
names(data) <- c("DO", "MR")
data$MR <- data$MR * t.denom
}else if(is.null(MR) == FALSE){
data$MR <- eval(parse(text = paste("data$", MR, sep = "")))
}
minimum.DO <-
as.numeric(min(data[data$DO <= Pcrit.below, 1], na.rm=TRUE))
zone.of.interest <- data[data$DO <= Pcrit.below,]
zone.of.interest <- zone.of.interest[order(zone.of.interest$DO,
decreasing=TRUE),]
RSS.table<-data.frame()
for(w in 2:length(zone.of.interest[,1])-1){
if(zone.of.interest$DO[w] != minimum.DO){
break.point <- zone.of.interest$DO[w]
RSS <- tot.rss(data = data,
break.pt = break.point,
xvar = "DO", yvar = "MR")
RSS.row <- cbind(RSS, zone.of.interest$DO[w])
RSS.table <- rbind(RSS.table,RSS.row)
}
}
DO.idx <- RSS.table[RSS.table$RSS == min(RSS.table$RSS), 2]
idx.rname <- row.names(RSS.table[RSS.table[,2] == DO.idx,])
DO.idx.low <- RSS.table[row.names(RSS.table) ==
(as.numeric(idx.rname)-1), 2]
midpoint.approx <- mean(c(DO.idx, DO.idx.low))
##creating linear models##
dat1 <- data[data$DO > DO.idx,]
mod.1 <- lm(dat1$MR~dat1$DO)
dat2 <- data[data$DO <= DO.idx,]
mod.2 <- lm(dat2$MR ~ dat2$DO)
sm1 <- summary(mod.1)
sm2 <- summary(mod.2)
adjr2.pre <- sm1$adj.r.squared
adjr2.post <- sm2$adj.r.squared
## Plot: line intersect##
plot(MR~DO, data, type= "n", ...)
points(x = c(dat1$DO, dat2$DO), y = c(dat1$MR, dat2$MR),
cex = .7, ...)
intersect<-(mod.2$coefficients[1] - mod.1$coefficients[1]) /
(mod.1$coefficients[2] - mod.2$coefficients[2])
names(intersect)<-NULL
if(is.na(mod.2$coefficients[2])==T){
abline(mod.1$coefficients[1], 0)
}else{abline(coef = mod.1$coefficients, col="red", lwd = 1.5, ...)}
abline(coef = mod.2$coefficients, col = "red", lwd = 1.5, ...)
points(x = intersect, y = mod.1$coefficients[1] +
mod.1$coefficients[2]*intersect, pch=21,
col = "blue", cex=1.5)
if (Pcrit.type == "lm" | Pcrit.type == "both"){
abline(v = intersect, col = "blue", lwd = 1.5,...)
}
if (Pcrit.type == "midpoint" | Pcrit.type == "both"){
abline(v = midpoint.approx, col = "lightblue", lwd = 1.5,...)
}
dat.pre<-data[data$DO>=(2*intersect),]
P.crit<-as.data.frame(cbind(intersect, midpoint.approx,
adjr2.pre, adjr2.post))
names(P.crit)<-c("Pcrit.lm", "Pcrit.midpoint",
"Adj.r2.above", "Adj.r2.below")
above.Pc <- list(mod.1)
names(above.Pc) <- "above"
below.Pc <- list(mod.2)
names(below.Pc) <- "below"
Pc<-c(P.crit, above.Pc, below.Pc)
return(Pc)
}
Pcrit2 <-get.pcrit(data = fishMR, DO = "DO.mgL",
Pcrit.below = 2,
idx.interval = 60,
start.idx = "2015-07-03 06:15:00",
stop.idx = "2015-07-03 08:05:00",
time.units = "min")
Pcrit2$above$coefficients
rm(list=ls())
library(devtools); install_github("tyler-l-moulton/rMR")
library(rMR)
library(rMR)
data(fishMR)
Pcrit1 <-get.pcrit(data = fishMR, DO = "DO.mgL",
Pcrit.below = 2,
idx.interval = 120,
start.idx = "2015-07-03 06:15:00",
stop.idx = "2015-07-03 08:05:00")
data(fishMR)
Pcrit1 <-get.pcrit(data = fishMR, DO = "DO.mgL",
Pcrit.below = 2,
idx.interval = 120,
start.idx = "2015-07-03 06:15:00",
stop.idx = "2015-07-03 08:05:00",)
data(fishMR)
Pcrit1 <-get.pcrit(data = fishMR, DO = "DO.mgL",
Pcrit.below = 2,
idx.interval = 120,
start.idx = "2015-07-03 06:15:00",
stop.idx = "2015-07-03 08:05:00", salinity = 30)
warnings()
data(fishMR)
## calc background resp rate
bgd.resp <-
background.resp(fishMR, "DO.mgL",
start.time = "2015-07-02 16:05:00",
end.time = "2015-07-02 16:35:00",
ylab = "DO (mg/L)", xlab = "time (min)")
bg.slope.a <- bgd.resp$mat[2]
starts <- c("2015-07-03 01:15:00", "2015-07-03 02:13:00",
"2015-07-03 03:02:00", "2015-07-03 03:50:00",
"2015-07-03 04:50:00")
stops <- c("2015-07-03 01:44:00", "2015-07-03 02:35:30",
"2015-07-03 03:25:00", "2015-07-03 04:16:00",
"2015-07-03 05:12:00")
metR <- MR.loops(data = fishMR, DO.var.name ="DO.mgL",
start.idx = starts, time.units = "hr",
stop.idx = stops, time.var.name = "std.time",
temp.C = "temp.C", elevation.m = 1180,
bar.press = NULL, in.DO.meas = "mg/L",
background.consumption = bg.slope.a,
ylim=c(6, 8))
metR$MR.summary
data(fishMR)
## calc background resp rate
bgd.resp <-
background.resp(fishMR, "DO.mgL",
start.time = "2015-07-02 16:05:00",
end.time = "2015-07-02 16:35:00",
ylab = "DO (mg/L)", xlab = "time (min)")
bg.slope.a <- bgd.resp$mat[2]
starts <- c("2015-07-03 01:15:00", "2015-07-03 02:13:00",
"2015-07-03 03:02:00", "2015-07-03 03:50:00",
"2015-07-03 04:50:00")
stops <- c("2015-07-03 01:44:00", "2015-07-03 02:35:30",
"2015-07-03 03:25:00", "2015-07-03 04:16:00",
"2015-07-03 05:12:00")
metR <- MR.loops(data = fishMR, DO.var.name ="DO.mgL",
start.idx = starts, time.units = "hr",
stop.idx = stops, time.var.name = "std.time",
temp.C = "temp.C", elevation.m = 1180,
bar.press = NULL, in.DO.meas = "mg/L",
background.consumption = bg.slope.a,
ylim=c(6, 8), salinity = 30)
metR$MR.summary
library(rMR)
data(fishMR)
## calc background resp rate
bgd.resp <-
background.resp(fishMR, "DO.mgL",
start.time = "2015-07-02 16:05:00",
end.time = "2015-07-02 16:35:00",
ylab = "DO (mg/L)", xlab = "time (min)")
bg.slope.a <- bgd.resp$mat[2]
starts <- c("2015-07-03 01:15:00", "2015-07-03 02:13:00",
"2015-07-03 03:02:00", "2015-07-03 03:50:00",
"2015-07-03 04:50:00")
stops <- c("2015-07-03 01:44:00", "2015-07-03 02:35:30",
"2015-07-03 03:25:00", "2015-07-03 04:16:00",
"2015-07-03 05:12:00")
metR <- MR.loops(data = fishMR, DO.var.name ="DO.mgL",
start.idx = starts, time.units = "hr",
stop.idx = stops, time.var.name = "std.time",
temp.C = "temp.C", elevation.m = 1180,
bar.press = NULL, in.DO.meas = "mg/L",
background.consumption = bg.slope.a,
ylim=c(6, 8), salinity = 30)
metR$MR.summary
metR <- MR.loops(data = fishMR, DO.var.name ="DO.mgL",
start.idx = starts, time.units = "hr",
stop.idx = stops, time.var.name = "std.time",
temp.C = "temp.C", elevation.m = 1180,
bar.press = NULL, in.DO.meas = "mg/L",
background.consumption = bg.slope.a,
ylim=c(6, 8))
metR$MR.summary
eqO2.1 <- Eq.Ox.conc(temp.C = 20, elevation.m = 1000)
eqO2.2 <- Eq.Ox.conc(temp.C = 20,
bar.press = 674.1, bar.units = "mmHg")
eqO2.1
eqO2.2
eqO2.1 <- Eq.Ox.conc(temp.C = 20, elevation.m = 1000, salinity = 30)
eqO2.2 <- Eq.Ox.conc(temp.C = 20,
bar.press = 674.1, bar.units = "mmHg", salinity =30)
eqO2.1
eqO2.2
data(fishMR)
## calc background resp rate
bgd.resp <-
background.resp(fishMR, "DO.mgL",
start.time = "2015-07-02 16:05:00",
end.time = "2015-07-02 16:35:00",
ylab = "DO (mg/L)", xlab = "time (min)")
bg.slope.a <- bgd.resp$mat[2]
starts <- c("2015-07-03 01:15:00", "2015-07-03 02:13:00",
"2015-07-03 03:02:00", "2015-07-03 03:50:00",
"2015-07-03 04:50:00")
stops <- c("2015-07-03 01:44:00", "2015-07-03 02:35:30",
"2015-07-03 03:25:00", "2015-07-03 04:16:00",
"2015-07-03 05:12:00")
metR <- MR.loops(data = fishMR, DO.var.name ="DO.mgL",
start.idx = starts, time.units = "hr",
stop.idx = stops, time.var.name = "std.time",
temp.C = "temp.C", elevation.m = 1180,
bar.press = NULL, in.DO.meas = "mg/L",
background.consumption = bg.slope.a,
ylim=c(6, 8), salinity = 30)
metR$MR.summary
DO.unit.convert <-
function(x, DO.units.in, DO.units.out,
bar.units.in, bar.press, temp.C,
bar.units.out = "mmHg",
salinity = 0 , salinity.units = "pp.thou"){
if(bar.units.in == bar.units.out){
bar.press <- bar.press
}else if(bar.units.in == "atm"){
if(bar.units.out == "mmHg"){
bar.press <- bar.press * 760
}else if(bar.units.out == "kpa"){
bar.press <- bar.press * 101.32501
}else{
stop("invalid 'bar.units.out' -- must be 'atm', 'mmHg', 'kpa'")
}
}else if(bar.units.in == "mmHg"){
if(bar.units.out == "atm"){
bar.press <- bar.press / 760
}else if(bar.units.out == "kpa"){
bar.press <- bar.press * 101.32501 / 760
}else{
stop("invalid 'bar.units.out' -- must be 'atm', 'mmHg', 'kpa'")
}
}else if(bar.units.in == "kpa"){
if(bar.units.out == "atm"){
bar.press <- bar.press / 101.32501
}
if(bar.units.out == "mmHg"){
bar.press <- bar.press * 760 / 101.32501
}
}
if (DO.units.in == "pct"){
DO.pct <- x / 100
}else{
eq.o2.in <- Eq.Ox.conc(temp.C, bar.units = bar.units.out,
bar.press =bar.press,
out.DO.meas = DO.units.in,
salinity = salinity,
salinity.units = salinity.units)
DO.pct <- x / eq.o2.in
}
if (DO.units.out == "pct"){
DO.conc <- DO.pct * 100
}else{
eq.o2.out <- Eq.Ox.conc(temp.C, bar.units = bar.units.out,
bar.press = bar.press,
out.DO.meas = DO.units.out,
salinity = salinity,
salinity.units = salinity.units)
DO.conc <- DO.pct * eq.o2.out
}
return(DO.conc)
}
DO.pct<- DO.unit.convert(x= 125.6863, DO.units.in = "PP",
DO.units.out = "pct",
bar.units.in = "mmHg", bar.press = 750, temp.C =15)
library(rMR)
DO.pct<- DO.unit.convert(x= 125.6863, DO.units.in = "PP",
DO.units.out = "pct",
bar.units.in = "mmHg", bar.press = 750, temp.C =15)
DO.pct<- DO.unit.convert(x= 125.6863, DO.units.in = "PP",
DO.units.out = "pct",
bar.units.in = "mmHg", bar.press = 750, temp.C =15, salinity = 30)
DO.pct1<- DO.unit.convert(x= 125.6863, DO.units.in = "PP",
DO.units.out = "pct",
bar.units.in = "mmHg", bar.press = 750, temp.C =15)
DO.pct<- DO.unit.convert(x= 125.6863, DO.units.in = "PP",
DO.units.out = "pct",
bar.units.in = "mmHg", bar.press = 750, temp.C =15, salinity = 30)
data(fishMR)
## calc background resp rate
bgd.resp <-
background.resp(fishMR, "DO.mgL",
start.time = "2015-07-02 16:05:00",
end.time = "2015-07-02 16:35:00",
ylab = "DO (mg/L)", xlab = "time (min)")
bg.slope.a <- bgd.resp$mat[2]
starts <- c("2015-07-03 01:15:00", "2015-07-03 02:13:00",
"2015-07-03 03:02:00", "2015-07-03 03:50:00",
"2015-07-03 04:50:00")
stops <- c("2015-07-03 01:44:00", "2015-07-03 02:35:30",
"2015-07-03 03:25:00", "2015-07-03 04:16:00",
"2015-07-03 05:12:00")
metR <- MR.loops(data = fishMR, DO.var.name ="DO.mgL",
start.idx = starts, time.units = "hr",
stop.idx = stops, time.var.name = "std.time",
temp.C = "temp.C", elevation.m = 1180,
bar.press = NULL, in.DO.meas = "mg/L",
background.consumption = bg.slope.a,
ylim=c(6, 8))
metR <- MR.loops(data = fishMR, DO.var.name ="DO.mgL",
start.idx = starts, time.units = "hr",
stop.idx = stops, time.var.name = "std.time",
temp.C = "temp.C", elevation.m = 1180,
bar.press = NULL, in.DO.meas = "mg/L",
background.consumption = bg.slope.a,
ylim=c(6, 8), salinity = 30)
DO.sat1 <- DO.saturation(DO.mgl = 5.5,
temp.C = 20, elevation.m = 1000)
DO.sat1a <- DO.saturation(DO.mgl = 5.5,
temp.C = 20, elevation.m = 1000, salinity = 30)
eqO2.2 <- Eq.Ox.conc(temp.C = 20,
bar.press = 674.1, bar.units = "mmHg")
eqO2.2 <- Eq.Ox.conc(temp.C = 20,
bar.press = 674.1, bar.units = "mmHg", salinity = 30)
?? CMD check
?? CMD
pack <- "rMR"
path <- find.package(pack)
system(paste(shQuote(file.path(R.home("bin"), "R")),
"CMD", "Rd2pdf", shQuote(path)))
citation(biglm)
citation("biglm")
library(devtools)
RCMD(build, path = "C:/Users/Tyler Moulton/Documents/rMR.orig")
setwd("C:/Users/Tyler Moulton/Documents/rMR.orig")
R CMD build rMR.orig
install.packages(Rtools)
install.packages("Rtools")
R CMD build rMR.orig
build()
check()
library(roxygen2)
library(roxygen2)
library(roxygen2)
library(roxygen2)
check()
library(roxygen2)
library(devtools)
build()
check()
Barom.Press <-
function(elevation.m, units = "atm"){
if(units == "atm") {fact <-1}
else if(units == "kpa") {
fact <- 101.325
}else if(units == "mmHg") {
fact <- 760
}else{
stop("invalid pressure units, must be
'atm', 'kpa', or 'mmHg'")
}
P<-exp(-9.80665 * 0.0289644 * elevation.m /
(8.31447 * 288.15))*fact
return(P)
}
Barom.Press(1000)
build()
check()
check()
check()
Pcrit4 <-get.pcrit(data = fishMR, DO = "DO.mgL",
Pcrit.below = 2,
idx.interval = 60,
start.idx = "2015-07-03 06:15:00",
stop.idx = "2015-07-03 08:05:00",
time.units = "hr",
ylab = "Met Rate (mg O2 / hour)",
Pcrit.type = NA)
library(rMR)
data(fishMR)
Pcrit4 <-get.pcrit(data = fishMR, DO = "DO.mgL",
Pcrit.below = 2,
idx.interval = 60,
start.idx = "2015-07-03 06:15:00",
stop.idx = "2015-07-03 08:05:00",
time.units = "hr",
ylab = "Met Rate (mg O2 / hour)",
Pcrit.type = NA)
Pcrit4 <-get.pcrit(data = fishMR, DO = "DO.mgL",
Pcrit.below = 2,
idx.interval = 60,
start.idx = "2015-07-03 06:15:00",
stop.idx = "2015-07-03 08:05:00",
time.units = "hr",
ylab = "Met Rate (mg O2 / hour)",
Pcrit.type = "")
rm(list=ls())
build()
build()
check()
install()
install()
build()
install()
check
check()
setwd("C:/Users/Tyler Moulton/Documents/rMR")
check()
build()
check()
install()
library(devtools)
install()
